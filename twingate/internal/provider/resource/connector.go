package resource

import (
	"context"
	"errors"
	"log"

	"github.com/Twingate/terraform-provider-twingate/twingate/internal/attr"
	"github.com/Twingate/terraform-provider-twingate/twingate/internal/client"
	"github.com/Twingate/terraform-provider-twingate/twingate/internal/model"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var ErrNotAllowChangeRemoteNetworkID = errors.New("connectors cannot be moved between Remote Networks: you must either create a new Connector or destroy and recreate the existing one")

func Connector() *schema.Resource {
	return &schema.Resource{
		Description:   "Connectors provide connectivity to Remote Networks. This resource type will create the Connector in the Twingate Admin Console, but in order to successfully deploy it, you must also generate Connector tokens that authenticate the Connector with Twingate. For more information, see Twingate's [documentation](https://docs.twingate.com/docs/understanding-access-nodes).",
		CreateContext: connectorCreate,
		ReadContext:   connectorRead,
		DeleteContext: connectorDelete,
		UpdateContext: connectorUpdate,
		CustomizeDiff: func(ctx context.Context, d *schema.ResourceDiff, m interface{}) error {
			oldVal, _ := d.GetChange(attr.RemoteNetworkID)
			old := oldVal.(string)
			if old != "" && d.HasChange(attr.RemoteNetworkID) {
				return ErrNotAllowChangeRemoteNetworkID
			}

			return nil
		},

		Schema: map[string]*schema.Schema{
			// required
			attr.RemoteNetworkID: {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The ID of the Remote Network the Connector is attached to.",
			},
			attr.Name: {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "Name of the Connector, if not provided one will be generated.",
			},
			// computed
			attr.ID: {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Autogenerated ID of the Connector, encoded in base64.",
			},
			attr.StatusUpdatesEnabled: {
				Type:        schema.TypeBool,
				Computed:    true,
				Optional:    true,
				Description: "Determines whether status notifications are enabled for the Connector.",
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func connectorCreate(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)

	connector, err := c.CreateConnector(ctx, &model.Connector{
		Name:                 resourceData.Get(attr.Name).(string),
		NetworkID:            resourceData.Get(attr.RemoteNetworkID).(string),
		StatusUpdatesEnabled: getOptionalBoolFlag(resourceData, attr.StatusUpdatesEnabled),
	})

	return resourceConnectorReadHelper(resourceData, connector, err)
}
func connectorUpdate(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	// allowed to change `name` and `status_updates_enabled`
	if !resourceData.HasChange(attr.Name) && !resourceData.HasChange(attr.StatusUpdatesEnabled) {
		return nil
	}

	connector := &model.Connector{
		ID:                   resourceData.Id(),
		Name:                 resourceData.Get(attr.Name).(string),
		StatusUpdatesEnabled: getOptionalBoolFlag(resourceData, attr.StatusUpdatesEnabled),
	}

	if !resourceData.HasChange(attr.Name) {
		connector.Name = ""
	}

	c := meta.(*client.Client)

	connector, err := c.UpdateConnector(ctx, connector)

	return resourceConnectorReadHelper(resourceData, connector, err)
}

func connectorDelete(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	connectorID := resourceData.Id()

	err := c.DeleteConnector(ctx, connectorID)
	if err != nil {
		return diag.FromErr(err)
	}

	log.Printf("[INFO] Destroyed connector id %s", connectorID)

	return nil
}

func connectorRead(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	connector, err := c.ReadConnector(ctx, resourceData.Id())

	return resourceConnectorReadHelper(resourceData, connector, err)
}

func resourceConnectorReadHelper(resourceData *schema.ResourceData, connector *model.Connector, err error) diag.Diagnostics {
	if err != nil {
		if errors.Is(err, client.ErrGraphqlResultIsEmpty) {
			// clear state
			resourceData.SetId("")

			return nil
		}

		return diag.FromErr(err)
	}

	if err := resourceData.Set(attr.Name, connector.Name); err != nil {
		return ErrAttributeSet(err, attr.Name)
	}

	if err := resourceData.Set(attr.RemoteNetworkID, connector.NetworkID); err != nil {
		return ErrAttributeSet(err, attr.RemoteNetworkID)
	}

	if connector.StatusUpdatesEnabled != nil {
		if err := resourceData.Set(attr.StatusUpdatesEnabled, *connector.StatusUpdatesEnabled); err != nil {
			return ErrAttributeSet(err, attr.StatusUpdatesEnabled)
		}
	}

	resourceData.SetId(connector.ID)

	return nil
}
