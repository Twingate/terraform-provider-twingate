package twingate

import (
	"context"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/twingate/go-graphql-client"
)

func resourceResource() *schema.Resource { //nolint:funlen
	portsResource := schema.Resource{
		Schema: map[string]*schema.Schema{
			"policy": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringInSlice([]string{"RESTRICTED", "ALLOW_ALL"}, false),
				Description:  "Whether to allow all ports or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed) or `ALLOW_ALL`",
			},
			"ports": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
		},
	}

	return &schema.Resource{
		Description:   "Resources in Twingate represent servers on the private network that clients can connect to. Resources can be defined by IP, CIDR range, FQDN, or DNS zone. For more information, see the Twingate [documentation](https://docs.twingate.com/docs/resources-and-access-nodes).",
		CreateContext: resourceResourceCreate,
		UpdateContext: resourceResourceUpdate,
		ReadContext:   resourceResourceRead,
		DeleteContext: resourceResourceDelete,

		Schema: map[string]*schema.Schema{
			// required
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The name of the Resource",
			},
			"address": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The Resource's IP/CIDR or FQDN/DNS zone",
			},
			"remote_network_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Remote Network ID where the Resource lives",
			},
			"group_ids": {
				Type:        schema.TypeSet,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Optional:    true,
				Description: "List of Group IDs that have permission to access the Resource, cannot be generated by Terraform and must be retrieved from the Twingate Admin Console or API",
			},
			"protocols": {
				Type:        schema.TypeList,
				Optional:    true,
				MaxItems:    1,
				Description: "Restrict access to certain protocols and ports. By default or when this argument is not defined, there is no restriction, and all protocols and ports are allowed.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_icmp": {
							Type:        schema.TypeBool,
							Optional:    true,
							Default:     true,
							Description: "Whether to allow ICMP (ping) traffic",
						},
						"tcp": {
							Type:     schema.TypeList,
							Required: true,
							MaxItems: 1,
							Elem:     &portsResource,
						},
						"udp": {
							Type:     schema.TypeList,
							Required: true,
							MaxItems: 1,
							Elem:     &portsResource,
						},
					},
				},
			},
			// computed
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Autogenerated ID of the Resource, encoded in base64",
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func convertGroupsGraphql(a []interface{}) []*graphql.ID {
	res := []*graphql.ID{}

	for _, elem := range a {
		id := graphql.ID(elem.(string))
		res = append(res, &id)
	}

	return res
}

func extractProtocolsFromContext(p interface{}) *StringProtocolsInput {
	protocolsMap := p.(map[string]interface{})
	protocolsInput := &StringProtocolsInput{}
	protocolsInput.AllowIcmp = protocolsMap["allow_icmp"].(bool)

	u := protocolsMap["udp"].([]interface{})
	if len(u) > 0 {
		udp := u[0].(map[string]interface{})
		protocolsInput.UDPPolicy = udp["policy"].(string)
		p := convertPortsToSlice(udp["ports"].([]interface{}))

		if len(p) > 0 {
			protocolsInput.UDPPorts = p
		}
	}

	t := protocolsMap["tcp"].([]interface{})
	if len(t) > 0 {
		tcp := t[0].(map[string]interface{})
		protocolsInput.TCPPolicy = tcp["policy"].(string)
		p := convertPortsToSlice(tcp["ports"].([]interface{}))

		if len(p) > 0 {
			protocolsInput.TCPPorts = p
		}
	}

	return protocolsInput
}

func extractResource(resourceData *schema.ResourceData) (*Resource, error) {
	resource := &Resource{
		Name:            graphql.String(resourceData.Get("name").(string)),
		RemoteNetworkID: graphql.ID(resourceData.Get("remote_network_id").(string)),
		Address:         graphql.String(resourceData.Get("address").(string)),
		GroupsIds:       convertGroupsGraphql(resourceData.Get("group_ids").(*schema.Set).List()),
	}

	p := resourceData.Get("protocols").([]interface{})

	if len(p) > 0 {
		p, err := extractProtocolsFromContext(p[0]).convertToGraphql()
		if err != nil {
			return nil, err
		}

		resource.Protocols = p
	} else {
		resource.Protocols = newEmptyProtocols()
	}

	return resource, nil
}

func resourceResourceCreate(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)

	resource, err := extractResource(resourceData)
	if err != nil {
		return diag.FromErr(err)
	}

	err = client.createResource(ctx, resource)
	if err != nil {
		return diag.FromErr(err)
	}

	resourceData.SetId(resource.ID.(string))
	log.Printf("[INFO] Created resource %s", resource.Name)

	return resourceResourceRead(ctx, resourceData, meta)
}

func resourceResourceUpdate(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)

	if resourceData.HasChanges("protocols", "remote_network_id", "name", "address", "group_ids") {
		resource, err := extractResource(resourceData)
		if err != nil {
			return diag.FromErr(err)
		}

		resource.ID = resourceData.Id()

		err = client.updateResource(ctx, resource)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return resourceResourceRead(ctx, resourceData, meta)
}

func resourceResourceDelete(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)

	var diags diag.Diagnostics

	resourceID := resourceData.Id()

	err := client.deleteResource(ctx, resourceID)
	if err != nil {
		return diag.FromErr(err)
	}

	log.Printf("[INFO] deleted resource id %s", resourceData.Id())

	return diags
}

func resourceResourceRead(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)
	resourceID := resourceData.Id()

	resource, err := client.readResource(ctx, resourceID)
	if err != nil {
		return diag.FromErr(err)
	}

	return resourceResourceReadDiagnostics(resourceData, resource)
}

func resourceResourceReadDiagnostics(resourceData *schema.ResourceData, resource *Resource) diag.Diagnostics {
	var diags diag.Diagnostics

	if err := resourceData.Set("name", resource.Name); err != nil {
		return diag.FromErr(fmt.Errorf("error setting name: %w ", err))
	}

	if err := resourceData.Set("remote_network_id", resource.RemoteNetworkID); err != nil {
		return diag.FromErr(fmt.Errorf("error setting remote network: %w ", err))
	}

	if err := resourceData.Set("address", resource.Address); err != nil {
		return diag.FromErr(fmt.Errorf("error setting address: %w ", err))
	}

	if err := resourceData.Set("group_ids", resource.stringGroups()); err != nil {
		return diag.FromErr(fmt.Errorf("error setting group_ids: %w ", err))
	}

	if len(resourceData.Get("protocols").([]interface{})) > 0 {
		protocols := resource.Protocols.flattenProtocols()
		if err := resourceData.Set("protocols", protocols); err != nil {
			return diag.FromErr(fmt.Errorf("error setting protocols: %w ", err))
		}
	}

	return diags
}
