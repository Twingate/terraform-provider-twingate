package twingate

import (
	"context"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resourceResource() *schema.Resource {
	portsResource := schema.Resource{
		Schema: map[string]*schema.Schema{
			"policy": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringInSlice([]string{"RESTRICTED", "ALLOW_ALL"}, false),
			},
			"ports": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Schema{
					Type:        schema.TypeString,
					Description: "List of port ranges 1 and 65535 inclusively, in the format '100-200' for a range , or '8080' a single port ",
				},
				//ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) {
				//	ports := val.([]string)
				//	for _, port := range ports {
				//		if strings.Contains(port, "-") {
				//			split := strings.SplitN(port, "-", 2)
				//			start, err := strconv.Atoi(split[0])
				//			if err != nil {
				//				errs = append(errs, fmt.Errorf("cant parse port %s, error : %w", split[0], err))
				//			}
				//			end, err := strconv.Atoi(split[1])
				//			if err != nil {
				//				errs = append(errs, fmt.Errorf("cant parse port %s, error : %w", split[1], err))
				//			}
				//			if start < 1 || start > 65535 || end < start || end > 65535 {
				//				errs = append(errs, fmt.Errorf("ports should be in range 1 to 65535 and %d should be smaller then %d", start, end))
				//			}
				//		} else {
				//			p, err := strconv.Atoi(port)
				//			if err != nil {
				//				errs = append(errs, fmt.Errorf("cant parse port %s, error : %w", port, err))
				//			}
				//			if p < 1 || p > 65535 {
				//				errs = append(errs, fmt.Errorf("port %d should be in range 1 to 65535", p))
				//			}
				//		}
				//
				//	}
				//	return
				//},
			},
		},
	}
	return &schema.Resource{
		CreateContext: resourceResourceCreate,
		UpdateContext: resourceResourceUpdate,
		ReadContext:   resourceResourceRead,
		DeleteContext: resourceResourceDelete,

		Schema: map[string]*schema.Schema{
			// required
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "name of the resource",
			},
			"address": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The resource's IP/FQDN",
			},
			"groups": {
				Type:        schema.TypeList,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Optional:    true,
				Description: "List of group IDs added to the resource",
			},
			"remote_network_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Remote Network ID to assign to the resource",
			},
			"protocols": {
				Type:        schema.TypeList,
				Optional:    true,
				MaxItems:    1,
				Description: "Restrict access to certain protocols and ports. By default or when this argument is not defined, there is no restriction i.e. all protocols and ports are allowed.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_icmp": {
							Type:        schema.TypeBool,
							Optional:    true,
							Default:     true,
							Description: "Whether to allow ICMP throughput",
						},
						"tcp": {
							Type:     schema.TypeList,
							Required: true,
							MaxItems: 1,
							Elem:     &portsResource,
						},
						"udp": {
							Type:     schema.TypeList,
							Required: true,
							MaxItems: 1,
							Elem:     &portsResource,
						},
					},
				},
			},
			// computed
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Autogenerated ID of the resource in encoded in base64",
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}
func convertSlice(a []interface{}) []string {
	var res = make([]string, 0)
	for _, elem := range a {
		res = append(res, elem.(string))
	}
	return res
}

func extractProtocols(p interface{}, protocols *Protocols) {
	protocolsMap := p.(map[string]interface{})
	protocols.AllowIcmp = protocolsMap["allow_icmp"].(bool)
	u := protocolsMap["udp"].([]interface{})
	t := protocolsMap["tcp"].([]interface{})
	if len(u) > 0 {
		udp := u[0].(map[string]interface{})
		protocols.UdpPolicy = udp["policy"].(string)
		protocols.UdpPorts = convertSlice(udp["ports"].([]interface{}))
	}
	if len(t) > 0 {
		tcp := t[0].(map[string]interface{})
		protocols.TcpPolicy = tcp["policy"].(string)
		protocols.TcpPorts = convertSlice(tcp["ports"].([]interface{}))
	}
}

func resourceResourceCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)

	protocols := &Protocols{}

	p := d.Get("protocols").([]interface{})
	if len(p) > 0 {
		extractProtocols(p[0], protocols)
	}

	resource := &Resource{
		Name:            d.Get("name").(string),
		RemoteNetworkId: d.Get("remote_network_id").(string),
		Address:         d.Get("address").(string),
		Groups:          convertSlice(d.Get("groups").([]interface{})),
		Protocols:       protocols,
	}
	err := client.createResource(resource)

	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(resource.Id)

	log.Printf("[INFO] Created resource %s", resource.Name)

	return resourceResourceRead(ctx, d, m)
}

func resourceResourceUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)
	_ = client
	//orderID := d.Id()
	//
	//if d.HasChange("protocols") {
	//
	//	client.updateResource()
	//
	//}

	return resourceResourceRead(ctx, d, m)
}

func resourceResourceDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)

	var diags diag.Diagnostics

	resourceId := d.Id()

	err := client.deleteResource(resourceId)
	if err != nil {
		return diag.FromErr(err)
	}

	log.Printf("[INFO] deleted resource id %s", d.Id())

	return diags
}

func resourceResourceRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)
	var diags diag.Diagnostics

	resourceId := d.Id()

	resource, err := client.readResource(resourceId)

	if err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set("name", resource.Name); err != nil {
		return diag.FromErr(fmt.Errorf("error setting name: %w ", err))
	}
	if err := d.Set("remote_network_id", resource.RemoteNetworkId); err != nil {
		return diag.FromErr(fmt.Errorf("error setting remote network: %w ", err))
	}
	if err := d.Set("address", resource.Address); err != nil {
		return diag.FromErr(fmt.Errorf("error setting address: %w ", err))
	}
	if err := d.Set("groups", resource.Groups); err != nil {
		return diag.FromErr(fmt.Errorf("error setting groups: %w ", err))
	}
	protocols := flattenProtocols(resource.Protocols)
	if err := d.Set("protocols", protocols); err != nil {
		return diag.FromErr(fmt.Errorf("error setting protocols: %w ", err))
	}

	return diags
}

func flattenProtocols(protocols *Protocols) []interface{} {
	if protocols != nil {
		p := make(map[string]interface{})

		p["allow_icmp"] = protocols.AllowIcmp
		p["tcp"] = flattenPorts(protocols.TcpPolicy, protocols.TcpPorts)
		p["udp"] = flattenPorts(protocols.UdpPolicy, protocols.UdpPorts)

		return []interface{}{p}
	}

	return make([]interface{}, 0)
}
func flattenPorts(policy string, ports []string) []interface{} {
	c := make(map[string]interface{})
	c["policy"] = policy
	c["ports"] = ports
	return []interface{}{c}
}
