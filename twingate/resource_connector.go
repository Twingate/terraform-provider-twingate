package twingate

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var ErrNotAllowChangeRemoteNetworkID = errors.New("not allowed to change remote_network_id")

func resourceConnector() *schema.Resource {
	return &schema.Resource{
		Description:   "Connectors provide connectivity to Remote Networks. This resource type will create the Connector in the Twingate Admin Console, but in order to successfully deploy it, you must also generate Connector tokens that authenticate the Connector with Twingate. For more information, see Twingate's [documentation](https://docs.twingate.com/docs/understanding-access-nodes).",
		CreateContext: resourceConnectorCreate,
		ReadContext:   resourceConnectorRead,
		DeleteContext: resourceConnectorDelete,
		UpdateContext: resourceConnectorUpdate,
		CustomizeDiff: func(ctx context.Context, d *schema.ResourceDiff, m interface{}) error {
			const key = "remote_network_id"
			oldVal, _ := d.GetChange(key)
			old := oldVal.(string)
			if old != "" && d.HasChange(key) {
				return ErrNotAllowChangeRemoteNetworkID
			}

			return nil
		},

		Schema: map[string]*schema.Schema{
			// required
			"remote_network_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The ID of the Remote Network to attach the Connector to",
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "Name of the Connector, if not provided one will be generated",
			},
			// computed
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Autogenerated ID of the Connector, encoded in base64",
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func resourceConnectorCreate(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)

	remoteNetworkID := resourceData.Get("remote_network_id").(string)
	connector, err := client.createConnector(ctx, remoteNetworkID)

	if err != nil {
		return diag.FromErr(err)
	}

	resourceData.SetId(connector.ID.(string))
	log.Printf("[INFO] Created conector %s", connector.Name)

	if resourceData.Get("name").(string) != "" {
		return resourceConnectorUpdate(ctx, resourceData, meta)
	}

	return resourceConnectorRead(ctx, resourceData, meta)
}
func resourceConnectorUpdate(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)

	connectorName := resourceData.Get("name").(string)

	if resourceData.HasChange("name") {
		connectorID := resourceData.Id()
		log.Printf("[INFO] Updating name of connector id %s", connectorID)

		if err := client.updateConnector(ctx, connectorID, connectorName); err != nil {
			return diag.FromErr(err)
		}
	}

	return resourceConnectorRead(ctx, resourceData, meta)
}
func resourceConnectorDelete(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)

	var diags diag.Diagnostics

	connectorID := resourceData.Id()

	err := client.deleteConnector(ctx, connectorID)
	if err != nil {
		return diag.FromErr(err)
	}

	log.Printf("[INFO] Destroyed connector id %s", connectorID)

	return diags
}

func resourceConnectorRead(ctx context.Context, resourceData *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*Client)

	var diags diag.Diagnostics

	connectorID := resourceData.Id()
	connector, err := client.readConnector(ctx, connectorID)

	if err != nil {
		return diag.FromErr(err)
	}

	if err := resourceData.Set("name", connector.Name); err != nil {
		return diag.FromErr(fmt.Errorf("error setting name: %w ", err))
	}

	return diags
}
